
//И вообще зачем нам создавать вот этот отдельный класс со своим конструктором?
//Не легче ли было бы создать общий метод перезапуска таймера прямо внутри класса AI_Controller? 
//Выносить Timer в отдельный класс — это "чистый код", масштабируемость и повторное использование.
//Лепить всё в AI_Controller — быстро, но ведёт к беспорядку.
//Если ты делаешь один Timer в AI_Controller — он жёстко привязан только к нему.
//А когда у тебя отдельный класс Timer, ты можешь: использовать его в любом ИИ, в стрельбе,
//перезарядке, уроне, ловушках, спецэффектах и т.д.
//Это многоразовый инструмент, как "секундомер", который ты кладёшь в карман любого скрипта.
//Класс Timer делает одну простую вещь — отсчитывает время.
//Это очень читаемо, особенно в сложной логике: тебе не нужно вспоминать,
//какие переменные хранят таймер, какой флаг его выключает, как его сбросить.
//Разделение ответственности
//AI_Controller отвечает за поведение врага.
//Timer отвечает за таймер.
//Это принцип SRP (Single Responsibility Principle) — один из столпов хорошего кода.
//Он гласит: один класс — одна ответственность.
//Если таймер багует, тебе не надо лезть в гигантский AI_Controller.
//Ты можешь проверить его отдельно.
//Что здесь происходит?
//для таймера создаём экземпляр класса Timer и тут же запускаем метод Start с переданным в него аргументом startTime.
//Дальше метод Start присваивает это значение полю m_CurrentTime.
//Потом из другого метода внутри класса AI_Controller вызывается для созданного экземпляра класса (для нашего таймера)
//вызывается метод RemoveTime с аргументом равным 0,016 секунды.
//И этот метод вызывается постоянно до тех пор пока значение m_CurrentTime не станет равным 0. 
//А дальше весь процесс повторяется по кругу.
//НО Ты создаёшь новый экземпляр только один раз, когда вызываешь: m_FindNewTargetTimer = new Timer(m_ShootDelay);
//А дальше используешь один и тот же экземпляр на протяжении всей жизни объекта. Просто снова и снова перезапускаешь его методом:
//m_FindNewTargetTimer.Start(m_ShootDelay);

//Мы создаём первый раз экземпляр класса и из конструктора вызываем для него Start(startTime);
//А во второй, третий и т.д. раз мы просто для нашего экземпляра класса вызываем метод Start: m_FindNewTargetTimer.Start(m_ShootDelay);
//при этом конструктор внутри класса Timer мы больше не трогаем. 

//Почему данный класс не наследуется от MonoBehaviour, не использует юзинги и не имеет namespace'а?
//Он не должен наследоваться от MonoBehaviour, потому что:
//Он не висит на GameObject'е.
//Он не нуждается в Start(), Update() или других встроенных Unity-методах.
//Он создаётся и используется внутри других скриптов — как обычный вспомогательный инструмент.
//using'и не нужны, потому что он использует только базовые типы из System, которые уже доступны по умолчанию (например, float, bool).
//namespace — не обязателен.Это просто организация кода.Обычно в маленьких проектах или в проектах
//для джемов от него отказываются ради краткости.

//класс Timer является шаблоном, с его помощью создаются три объекта-таймера,
//в нём есть методы: Start, RemoveTime, которые обновляют таймер и уменьшают значения таймеров.
//Также тут есть булево поле  IsFinished, которое в других методах показывает, что таймер завершён.
//Также есть поле m_CurrentTime, из значения которого мы каждый кадр отнимаем 0,016 секунды.

//Ты абсолютно верно понял, что класс Timer — это микро-система отсчёта времени,
//и он реализован в виде простого C#-объекта, который не зависит от Unity напрямую,
//но используется внутри MonoBehaviour-ов для управления логикой (перезарядка, смена цели, поворот и т.д.).


namespace Common
{
    public class Timer
    {
        private float m_CurrentTime;

        public bool IsFinished => m_CurrentTime <= 0;

        public Timer(float startTime)
        {
            Start(startTime);
        }

        public void Start(float startTime)
        {
            m_CurrentTime = startTime;
        }

        public void RemoveTime(float deltaTime)
        {
            if (m_CurrentTime <= 0) return;

            m_CurrentTime -= deltaTime;
        }
    }
}

