using System.Security.Cryptography;
using UnityEngine;
using UnityEngine.UIElements;
using Common;

namespace SpaceShooter
{
    [RequireComponent(typeof(SpaceShip))]
    public class AI_Controller : MonoBehaviour
    {
        public enum AIBehaviour
        {
            Null,
            Patrol
        }
        [SerializeField] private AIBehaviour m_AIBehaviour;

        [SerializeField] private AIPointPatrol m_PatrolPoint;

        [Range(0.0f, 1.0f)]
        [SerializeField] private float m_NavigationLinear;

        [Range(0.0f, 1.0f)]
        [SerializeField] private float m_NavigationAngular;

        [Range(0.0f, 5.0f)]
        [SerializeField] private float m_RandomSelectMovePointTime;
        //[Range(0.0f, 5.0f)] — добавляет ползунок в инспекторе, позволяя выбрать значение от 0 до 5.

        [SerializeField] private float m_FindNewTargetTime;
        [SerializeField] private float m_ShootDelay;
        [SerializeField] private float m_EvadeRayLength;

        //три кэшированные переменные:
        [SerializeField] private SpaceShip m_SpaceShip;
       
        

        private Vector3 m_MovePosition; // Точка, куда двигается наш корабль
        private Destructible m_SelectedTarget; // у корабля есть некая цель (Какой-то объект)
        // то есть в этих двух строчках мы разделяем точку, куда двигаться и ссылку на объект слежения
        //m_SelectedTarget  — это цель, которую бот выбрал для атаки.
        //В большинстве случаев — это будет игрок, потому что у игрока есть компонент
        //Destructible. А метод FindNearestDestructibleTarget() ищет
        //ближайшую подходящую цель среди всех объектов с Destructible.
        //Бот выбирает ближайший объект с Destructible.

        private Timer TestTimer;


        private Timer m_RandomizeDirectionTimer;
        private Timer m_FireTimer;
        private Timer m_FindNewTargetTimer;

        [SerializeField] private SpaceShooter.AIPointPatrolPath m_PatrolPath;

        private int m_CurrentPatrolIndex = 0;
        


        private void Start()
        {
            m_SpaceShip = GetComponent<SpaceShip>();
            InitTimers();
        }

        private void Update()
        {
            UpdateTimers();
            UpdateAI();
        }

        private void UpdateAI()
        {
            if (m_AIBehaviour == AIBehaviour.Patrol)
            {
                UpdateBehaviourPatrol();
            }
        }

        private void UpdateBehaviourPatrol()
        {
            ActionFindNewPatrolPoint();
            ActionControlShip();          // движемся к текущей цели
            ActionEvadeCollision();
            ActionFindNewAttackTarget();
            ActionFire();
        }

        private void ActionControlShip()
        {
            Vector3 direction = m_MovePosition - transform.position;
            float distance = direction.magnitude;
           
            float angle = ComputeAliginTorqueNormalized(m_MovePosition, m_SpaceShip.transform);

            //m_NavigationAngular - это поле, доступное в инспекторе, в котором настраивается "скорость" поворота корабля. Если не умножать на это значение, корабль поворачиваться не будет.

            m_SpaceShip.ThrustControl = m_NavigationLinear; // газ в пол

            m_SpaceShip.TorqueControl = angle * m_NavigationAngular;

        }


        private const float MAX_ANGLE = 45.0f; // максимальный угол для нормализации поворота
        // Здесь задаю тот угол, после которого мы считаем, что кораблю нужно крутить на полную. 

        private static float ComputeAliginTorqueNormalized(Vector3 targetPosition, Transform ship) 
            // Статичный метод, который возвращает float, то есть некий УГОЛ
            // этот метод - это расчёт поворотного момента для выравнивания по подлёту к цели
            // в этом методе я вычисляю точно НОРМАЛИЗОВАННЫЙ поворот корабля к цели, чтобы он не улетел в другой какой-то угол
        {
            Vector2 localTargetPosition = ship.InverseTransformPoint(targetPosition);
            // переводит позицию в локальные координаты

            float angle = Vector3.SignedAngle(localTargetPosition, Vector3.up, Vector3.forward);
            // получаем угол между двумя векторами. Здесь вычисляю угол между направлениями: на цель и осью вперёд
            // SignedAngle - это угол со знаком
            // Почему в параметре метода SignedAngle мы пишем up то есть Vector3.up  и .forward?
            //При наведении на метод SignedAngle третьим параметром будет Vector3 axis - то ось.
            // В данном методе три параметра: 1. Откуда будет идти вектор 2. Куда будет идти вектор 3. Ось - по которой вектор
            //будет двигаться с этими параметрами. 
            //В данной строчке мы задаём направление движения. Здесь выисляется второй вектор, то есть его
            //точка откуда он пойдёт, точка куда он дойдёт и ось, по которой он двигается. 
            // То есть мы находим один вектор, а именно тот вектор, в сторону которого будет смотреть
            //бот после своего поворота. Изначально у бота имеется первый вектор, так как бот смотрит
            //в какую-то сторону и у него априори в эту сторону смотрит вектор. То есть этот вектор
            //у нас есть изначально априори, нам го не нужно вычислять и соответственно НЕ нужно для
            //его вычисления вызывать какой-либо метод.
            // И вот получается, что мне надо вычислить угол (angle) между двумя векторами:
            //первый вектор у нас есть априори (мы его не видим в коде), а второй вектор мы вычисляем 
            //с помощью данного метода SignedAngle. В этот метод мы передаём: 1. позицию, откуда будет бот поворачивать,
            // 2. конечную точку, куда будет протянут вектор (То есть создаётся направление вектора) 3. Ось, по которой
            // бот будет двигаться. И вот с помощью этих трех параметров и с помощью изначально имеющегося
            // первого вектора (того, куда изначально смотрит бот) метод SignedAngle вычисляет угол поворота бота.
            //ТАКЖЕ я могу с помощью f12 перейти в метод SignedAngle и посмотреть, что он делает. Вот что он делает:
            //Смотрю над этим методом в бибилиотеке - там есть Summary: там описываются, что за параметры передаются.
            //Там есть надпись: Returns the signed angle between from and to in degrees - означает, что: возвращает
            // угол в градусах между вектором откуда поворачивается объект(from) и вектором куда будет смотреть
            //объект после поворота(to). from and to - имеется в виду два вектора.

            if (Mathf.Abs(angle) < 2.0f) // Если модуль угла меньше 2°, то мы не поворачиваем, а летим прямо
                return 0;
            angle = Mathf.Clamp(angle, -MAX_ANGLE, MAX_ANGLE) / MAX_ANGLE; //  делим на 45 градусов чтобы нормализовать угол от минус 1 до плюс 1.
                                                                           //данный метод возвращает значение, если оно попадает в этот range (от -45.f до +45.0f),
                                                                           //далее это значение делим на 45 градусов(MAX_ANGLE), чтобы вывести нормализованное значение.
                                                                           // Нормализовать угол - это значит привести его из градусов к диапазону от -1 до +1.
                                                                           // Эта строчка ограничивает наш угол
                                                                           //Если наш угол становится больше 45 градусов, то ОН ПРОСТО 45 градусов.
                                                                           // Т.е. у нас всегда будет ограничение от 0 до 45 градусов.
                                                                           //Посчитанный угол нужно перевести в нормализованные координаты, т.е. разделить на 45.
                                                                           //В итоге, если наша целевая точка находится больше чем на 45 градусов от нас в повороте,
                                                                           //то мы максимальном жмём педаль в пол, чтобы наш корабль повернул. 
                                                                           //Если меньше, то тогда получаем какое-то меньшее значение. 
                                                                           //При маленьких значениях корабль будет плавно совсем чуть-чуть доворачивать до цели.
                                                                           // Чем больше я поворачиваю корабль, тем больше нужно применить силы к вращательному моменту.
                                                                           // Как только угол становится больше чем 45 градусов, я всегда применяю полную силу для вращения
            return -angle;
            // нужно вернуть отрицательное значение, чтобы поворот был 
            // в правильном направлении. 
            // Здесь возврат отрицательного значения по двум причинам:
            // 1. Соглашение о знаке в Юнити, то есть функция Vector3.SignedAngle даёт угол,
            // на который нужно повернуть вектор. При этом положительный угол - это вращение против часовой стрелки,
            // а отрицательный угол - это вращение по часовой стрелке. 
            // в нашем API управление задаётся свойством TorqueControl. Оно ожидает положительное значение, когда нужно крутить
            // корабль по часовой стрелке, и отрицательное, когда влево (против часовой стрелки).  
            // Мы здесь делаем инверсию для правильного направления. Потому что если вернуть в TorqueControl просто angle, то
            // в таком случае корабль ПО ЛОГИКЕ ЮНИТИ стал бы крутиться против часовой стрелки, то есть влево, то есть в противопложную
            // сторону от заданной целевой точки. И именно поэтому мы возвращаем -angle, то есть мы делаем инверсию для правильного направления.
            // Нам надо взять обратный знак от того, что вернул SignedAngle. 
            // И поэтому, мы после нормализации делаем минус angle.
            //если цель справа, angle будет отрицательным. -angle превращается в положительный угол и крабль повернёт вправо. 
            
        }



        private void ActionFindNewMovePosition()
        {
            //Таймер здесь нужен для того, чтобы пока игрок не замечен (m_SelectedTarget == null),
            //враг постоянно патрулировал зону (без таймера он бы только один раз нашел точку внутри
            //патрульной зоны и приблизился к ней, после чего остановился).
            if (m_AIBehaviour == AIBehaviour.Patrol)
            {
                if (m_SelectedTarget != null)
                //А если m_SelectedTarget не равен null, то есть игрок замечен, то враг двигается к игроку.
                //Но в настоящем, живом проекте всегда лучше подстраховаться и сделать null-проверку, потому что это защищает от ошибок.
                //m_SelectedTarget — это цель, которую бот выбрал для атаки.
                {
                    m_MovePosition = m_SelectedTarget.transform.position;
                }
                else
                //Когда m_SelectedTarget равен null, значит корабль сейчас не видит игрока
                //и в качестве точки маршрута получает случайную точку внутри зоны патруля. 
                //В случае, когда m_SelectedTarget равняется null, то мы сперва проверяем,
                //что m_PatrolPoint НЕ равен null. Вопрос: где у нас задаётся m_PatrolPoint? 
                //Ответ: значение данного поля задаётся в инспекторе в качестве компонента.
                {
                    if (m_PatrolPoint != null) //Что такое m_PatrolPoint? Это ссылка на объект, у которого есть компонент AIPointPatrol.
                                               //Этот объект в Unity — обычно не просто "точка", а целая "зона", которая имеет:
                                               //позицию(transform.position) — это и есть ЦЕНТР зоны патруля;
                                               //радиус(Radius) — размер этой зоны; возможно, визуализацию через OnDrawGizmos().
                                               //То есть одновременно верно:
                                               //"m_PatrolPoint — это объект-зона" Это GameObject с компонентом AIPointPatrol.
                                               // "m_PatrolPoint — это центр зоны" Тоже верно, когда ты обращаешься к m_PatrolPoint.transform.position.
                                               // Это точка в пространстве, где находится центр зоны патрулирования.
                                               //m_PatrolPoint — это объект зоны патруля.
                                               //m_PatrolPoint.transform.position — это центр этой зоны (вектор позиции в пространстве).
                                               //Как правильно это сказать?
                                               //"m_PatrolPoint — это объект зоны патрулирования, а его transform.position — это центр этой зоны."
                                               //значение m_PatrolPoint задаётся в инспекторе - мы в это поле перетаскиваем скрипт AIPointPatrol.
                                               //m_PatrolPoint — это и есть ссылка на объект-зону патрулирования (класс AIPointPatrol).
                                               //Проверка if (m_PatrolPoint != null) означает:
                                               // “Назначена ли зона патруля вообще ?”
                                               // Получается, что поле m_PatrolPoint - это есть наша выделенная зона.
                                               // И этой проверкой мы выясняем, существует ли наша зона:  if (m_PatrolPoint != null). 
                                               //Но я не понимаю как поле m_PatrolPoint вообще может равняться null?
                                               //Мы же ведь скрипт AIPointPatrol перетащили в это поле в инспекторе - стало
                                               //быть это поле НЕ равняется null постоянно на протяжении всего времени игры? 
                                               //Во время игры это поле действительно НЕ будет равно null.
                                               //Тогда зачем вообще писать if (m_PatrolPoint != null)?
                                               //Ответ: Чтобы защитить код от ошибки, если вдруг это поле
                                               //забыли заполнить в инспекторе, или если бот спаунится динамически
                                               //и его m_PatrolPoint устанавливается позже через код.
                    {
                        bool isInsidePatrolZone = (m_PatrolPoint.transform.position - transform.position).sqrMagnitude < m_PatrolPoint.Radius * m_PatrolPoint.Radius;
                        //Эта строка отвечает на вопрос: "Находится ли бот внутри радиуса зоны патрулирования?"
                        //Операция (m_PatrolPoint.transform.position - transform.position).sqrMagnitude вычисляет КВАДРАТ ДЛИНЫ ВЕКТОРА, направленного от transform.position до m_PatrolPoint.transform.position.
                        // То есть, если вектор = new Vector3(x, y, z), то sqrMagnitude = x² + y² + z².
                        //Здесь нам НЕ надо вычислять и не надо нормализовать длину двух векторов. 
                        // Также нам не нужно здесь нормализовать квадрат длины полученного вектора.
                        // Нормализуют только сами векторы, когда важно направление, а не расстояние.
                        //В нашем случае нормализация не нужна вообще, потому что мы сравниваем расстояния, а не направления.  
                        //Стало быть, если m_PatrolPoint НЕ равен null, то значит это поле содержит всю зону для патрулирования.
                        // m_PatrolPoint.transform.position - transform.position -- Это вычитание двух векторов. Оно даёт вектор от бота к центру зоны патрулирования.
                        // Далее надо найти длину вектора. А длина вектора — это и есть расстояние между двумя точками. Вектор — это направление + расстояние.
                        //узнаём расстояние между двумя точками: m_PatrolPoint.transform.position — центр зоны патрулирования и transform.position — позиция нашего бота.
                        //m_PatrolPoint.transform.position - transform.position -- здесь мы получаем вектор, направленный от корабля к центру зоны патруля.
                        //точкаB - точкаA = вектор от A к B.  
                        //Это базовая геометрия вектора: разность двух точек — это вектор, который указывает из одной точки в другую.
                        //данная строка проверяет, находится ли AI внутри зоны патрулирования с радиусом m_PatrolPoint.Radius
                        // Вычитаем позицию текущего объекта (`transform.position`) из позиции точки патрулирования (`m_PatrolPoint.transform.position`)
                        //.sqrMagnitude — это квадрат длины полученного вектора.
                        // Мы сравниваем квадрат расстояния с квадратом радиуса.
                        //.sqrMagnitude возвращает квадрат длины вектора (без извлечения квадратного корня).  
                        //-Это быстрее, чем.magnitude, потому что не требует вычисления квадратного корня.
                        //Получается, что:
                        //`(A - B).sqrMagnitude` — это быстрый способ проверить, находится ли объект в пределах радиуса, без вычисления квадратного корня.  
                        // Сравниваем с `Radius* Radius`, потому что работаем с квадратами.
                        // Если квадрат длины вектора меньше чем квадрат радиуса, то isInsidePatrolZone становится равной true
                        // и мы делаем следующую проверку



                        if (isInsidePatrolZone == true)
                        {
                            if (m_RandomizeDirectionTimer.IsFinished == true)
                            //используется для регулярного изменения направления движения,
                            //чтобы бот не менял направление каждую миллисекунду, а делал это раз в несколько секунд
                            //То есть:
                            //— Пока таймер не закончился - бот летит в старую точку
                            //— Таймер закончился - бот выбирает новую точку
                            //Без таймера бот мог бы слишком часто (например, каждый кадр) менять направление — что привело бы к: Дёрганому, нереалистичному движению;
                            //таймер m_RandomizeDirectionTimer управляет тем, как часто бот меняет направление или точку патрулирования.
                            // Если внутри патрульной зоны и прошёл таймер, то выбрать новую точку.
                            //Таймер m_RandomizeDirectionTimer управляет интервалами между действиями внутри зоны патруля,
                            //чтобы бот выглядел разумно и не дёргался. Это ключ к созданию живого ИИ, а не просто анимации по кругу.
                            {
                                Vector2 newPoint = UnityEngine.Random.onUnitSphere * m_PatrolPoint.Radius + m_PatrolPoint.transform.position;
                                //Эта строка генерирует случайную точку на границе круга или внутри круга,
                                //центр которого — m_PatrolPoint.transform.position, а радиус — m_PatrolPoint.Radius.
                                //`Random.onUnitSphere` — это команда, которая создаёт случайное направление в 3D-пространстве.
                                // - Random.onUnitSphere возвращает вектор длиной 1, который указывает в случайном направлении в 3D.
                                //Но ты сохраняешь это в Vector2, так что ось Z будет отброшена,
                                //и в итоге получится случайный вектор на окружности в 2D-плоскости (XY).
                                //Затем делаю умножение: * m_PatrolPoint.Radius
                                //Это умножение нужно для того, чтобы изменить длину вектора, то есть:
                                //UnityEngine.Random.onUnitSphere даёт вектор длины 1 в случайном направлении,
                                // А вот эта часть: * m_PatrolPoint.Radius превращает его в вектор длины Radius, таким образом, сначала
                                //я беру направление, куда бот может пойти, а затем я говорю: "пройди по этому направлению ровно на Radius».
                                // В итоге я получаю  точку, удалённую от центра круга ровно на Radius, в случайном направлении.
                                // Если ты не умножишь на Radius, то точка будет на расстоянии 1, а не на расстоянии Radius — и она окажется внутри круга,
                                // но слишком близко к центру. Это сломает патрулирование, потому что бот не будет охватывать всю зону.

                                //что вот это такое, точка или вектор: Vector2 newPoint?
                                //Vector2 newPoint — это вектор, который в данном контексте представляет точку в 2D-пространстве.
                                //ВСЁ дело в том, что В Unity (и в математике) векторы могут означать как "смещение", так и "позицию в пространстве".
                                //В данном случае newPoint — это координаты случайной точки на круге патрулирования, то есть позиция, куда может пойти бот.
                                //Vector2 newPoint — это вектор, но семантически он используется как точка в 2D-пространстве.
                                //Важное понятие в программировании и математике:
                                // Что такое вектор?
                                //Вектор — это объект, который имеет:
                                //Направление(куда указывает), и
                                //Длину(модуль).
                                //Как используют векторы в Unity и математике?
                                //В одном контексте вектор — это именно "смещение" или "направление".
                                //Например, Vector3(1, 0, 0) — это вектор, который указывает на один метр вправо от точки отсчёта.
                                //В другом контексте тот же вектор можно воспринимать как координаты точки в пространстве,
                                //если считать начало координат (0,0,0) точкой отсчёта. Тогда (1, 0, 0) — это координаты точки,
                                //расположенной на один метр вправо.
                                //transform.position — это позиция объекта в пространстве, типа Vector3 (вектор, но он описывает точку).
                                //Vector3.right — это направление (вектор), указывающий вправо.
                                //Технически и то, и другое — объекты типа Vector3, но по смыслу одно — точка, другое — направление.
                                //Пример:
                                //Vector3 position = new Vector3(5, 0, 0);  точка в пространстве. Это координаты, где находится объект, например, твой корабль.
                                //Vector3 offset = new Vector3(1, 0, 0); смещение вправо на 1 (направление). Это вектор, который указывает, на сколько и в какую сторону надо сдвинуться от какой-то другой точки.
                                //Например, (1, 0, 0) — значит сдвинуться на 1 метр вправо.
                                //По структуре и типу обе переменные — просто набор трёх чисел Vector3. В математике и в Unity это одинаковый тип данных.
                                //Разница — в том, как ты их используешь и называешь.
                                //Ключевой момент: Сам смысл вектора задаёт его использование в твоём коде и логике, а не тип или формат.
                                //Различать эти векторы помогает контекст и то, что с ними делают в коде.
                                //Если переменная описывает место — это точка. Если — смещение или направление — это вектор-направление.
                                //Как различать: когда вектор - это точка, а когда - направление:
                                //Если вектор хранится в переменной с названием, связанным с позицией (position, targetPoint, startPoint) — воспринимай его как точку в пространстве.
                                //Если вектор используется для обозначения направления, скорости, смещения (direction, velocity, offset, movement) — это направление или расстояние между точками.
                                //Vector3 direction = targetPoint - position; // вектор-направление от position к targetPoint
                                //Vector3 velocity = new Vector3(1, 0, 0);   // направление и скорость
                                //Когда ты видишь операцию вычитания векторов (B - A), результат — вектор-направление (от A к B).
                                //Когда ты просто видишь вектор, присвоенный переменной с названием типа position — это точка.
                                //Вектор — это и точка, и линия (направление), и это нормально. Главное — понимать, что именно он обозначает в конкретном месте твоего кода.
                                //В математике и в программировании вектор — просто набор чисел (координат), и как их интерпретировать — зависит от задачи.
                                //В Unity, например, transform.position — это вектор, который мы понимаем как точку(где объект стоит).
                                //А вот Vector3.forward — это вектор-направление.

                                //Возвращаюсь к моему коду:
                                //Vector2 newPoint — это вектор, но семантически он используется как точка в 2D-пространстве.
                                // В мировых координатах наша полученная выше точка пока что отсчитывается от мирового центра, то есть от точки (0, 0, 0).
                                // "Центр нашей зоны не совпадает с мировым 0,0". Именно.Он, например, может быть в(50, 0, -10) или где угодно в сцене.
                                // "Поэтому прибавляем m_PatrolPoint.transform.position". Да! Это мировые координаты центра зоны, и прибавление этого
                                // значения переносит нашу точку из "локальной системы координат зоны" в мировую систему координат Unity.
                                // Другими словами  ТО ЖЕ САМОЕ:
                                //Значит, мы получили рандомную точку на окружности зоны (удалённость точки от центра зоны = Radius).
                                //В мировых координатах наша точка пока что отсчитывается от мирового центра, то есть 0,0.
                                //Но центр нашей зоны не совпадает с мировым 0,0, а он где-то в другом месте.
                                //И поэтому мы с помощью вот этого прибавления: + m_PatrolPoint.transform.position; смещаем нашу точку туда,
                                //где фактически находится в мире наша зона. То есть прибавляем к ней мировые координаты центра нашей зоны.
                                //И именно вот это и делает прибавление: + m_PatrolPoint.transform.position, то есть прибавляет к нашей точке
                                //мировые координаты центра нашей зоны. 
                                // 

                                m_MovePosition = newPoint;

                                m_RandomizeDirectionTimer.Start(m_RandomSelectMovePointTime);
                                //Мы перезапускаем таймер, чтобы он начал отсчитывать m_RandomSelectMovePointTime секунд,
                                //после чего, будет выбрана новая точка движения для персонажа.
                                //.Start(...) — метод этого таймера, который запускает отсчёт времени. Он принимает аргумент — продолжительность.
                                //Метод Start() запускает таймер с заданным временем (m_RandomSelectMovePointTime).
                                //Таймер отсчитывается в методе private void UpdateTimers().
                                //в этой строке мы перезапускаем таймер и когда у нас снова выполнится
                                //это условие: if (m_RandomizeDirectionTimer.IsFinished == true), то будет назначена новая рандомная точка, куда полетит наш бот.
                                //А что если этот счётчик закончится быстрее, чем бот успеет долететь до предыдущей точки, что тогда?
                                //Тогда всё просто и логично: бот “передумает” и полетит к новой точке, не достигнув старой.
                                //Это стандартное поведение для “блуждающего” ИИ.
                                //А если корабль долетит до точки раньше, чем закончится таймер?
                                //В этом случае корабль ничего не делает, просто висит в точке A, пока не сработает таймер.
                                //m_RandomSelectMovePointTime — значение, которое я задаю в Unity через инспектор. Здесь оно = 5 секунд.
                            }

                        }
                        else
                        {
                            m_MovePosition = m_PatrolPoint.transform.position;
                            //m_PatrolPoint.transform.position - это центр нашей окружности
                            //Почему именно это значение присваивают m_MovePosition, когда бот вышел за границу?
                            //Потому что: isInsidePatrolZone == false означает: корабль вышел за пределы зоны патрулирования.
                            //В этом случае бот должен вернуться обратно внутрь зоны.
                            //m_PatrolPoint.transform.position — это безопасная, заранее заданная центральная точка зоны, куда бот точно должен вернуться.
                            //т.о. строка означает: "Ты вышел за границы патруля? Срочно возвращайся в центр зоны!"
                        }
                    }
                }
            }
        }

        private void ActionEvadeCollision()
        {
            var hit = Physics2D.Raycast(transform.position, transform.up, m_EvadeRayLength);
            if (hit.collider != null) //Если Raycast с чем-то пересёкся
            {
                m_MovePosition = transform.position + transform.right * 100.0f; //поворачиваю вправо, если вижу впереди какое-то препятствие
            }
        }


    

      



        private void ActionFindNewPatrolPoint()
        {
            if (m_PatrolPath == null || m_PatrolPath.Length == 0)
            {
                Debug.LogWarning("m_PatrolPath is NULL or empty!");
                return;
            }
          
            m_MovePosition = m_PatrolPath.GetPoint(m_CurrentPatrolIndex).position;
            Debug.DrawLine(transform.position, m_MovePosition, Color.red);
            Debug.Log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Новая цель патруля: " + m_MovePosition);


            if (Vector3.Distance(transform.position, m_MovePosition) < 1.0f)
            {
                m_CurrentPatrolIndex++;

                if (m_CurrentPatrolIndex >= m_PatrolPath.Length)
                {
                    m_CurrentPatrolIndex = 0;
                    Debug.Log("Начинаем патруль заново");
                }

                m_MovePosition = m_PatrolPath.GetPoint(m_CurrentPatrolIndex).position;
               
            }
        }
        //мы проверяем на null целый класс, точнее — ссылку на экземпляр этого класса.
        //m_PatrolPath == null
        //— означает:
        //“А задан ли вообще этот объект? Или он пустой(не присвоен) ?”
        //Это ссылка на экземпляр класса AIPointPatrolPath, и она может быть null, если:
        //ты не установил её в инспекторе,
        //объект ещё не создан,
        //или был уничтожен(Destroy()),
        //или бот заспавнился без маршрута.

        //m_PatrolPath.Length == 0
        //— это уже вызов публичного свойства внутри объекта.
        //Оно обычно возвращает длину массива точек патруля.


        private void ActionFindNewAttackTarget()
        {
            if (m_FindNewTargetTimer.IsFinished == true)
            //m_FindNewTargetTimer — это не просто поле, а объект специального класса, который отвечает за тайминг (время ожидания).
            // private Timer m_FindNewTargetTimer -- Это поле, скорее всего, объект кастомного класса
            //Где Timer — это не встроенный класс Unity, а твой (или чей-то) пользовательский класс, для которого у меня есть отдельный скрипт
            //Зачем вообще нужен этот таймер? Чтобы не искать новую цель слишком часто — это экономит производительность и делает поведение реалистичнее.
            //если бы мы не поставили таймер, то FindNearestDestructibleTarget() вызывался бы каждый кадр,
            //то есть 60+ раз в секунду, что бессмысленно и затратно.
            {
                //  только раз в N секунд:
                m_SelectedTarget = FindNearestDestructibleTarget();

                m_FindNewTargetTimer.Start(m_ShootDelay);
                //Метод Start(m_ShootDelay) запускает отсчёт таймера с задержкой m_ShootDelay.
                //то есть здесь всё по такому же принципу, как и с предыдущим таймером: делаем проверку
                //if (m_FindNewTargetTimer.IsFinished == true) если таймер закончился, а мы уменьшаем его каждый
                //кадр в методе UpdateTimers вот этой строкой:  m_FindNewTargetTimer.RemoveTime(Time.deltaTime);
                //Так вот, если таймер закончился, то выполняем это: m_SelectedTarget = FindNearestDestructibleTarget();
                //и перезапускаем отсчёт таймера: m_FindNewTargetTimer.Start(m_ShootDelay); и так по кругу. 
                //Ты построил повторяющийся цикл на таймере: Ждать → Выполнить → Снова ждать → Снова выполнить → и т.д.
                //Это очень типичная и правильная игровая логика для ИИ: не делать одно и то же каждый кадр,
                //а через разумные промежутки времени.
            }
        }

        private void ActionFire()
        {
            if (m_SelectedTarget != null)
                //Что означает if (m_SelectedTarget != null)?
                //Это просто проверка: а есть ли вообще цель, в которую стрелять ?
            {
                if (m_FireTimer.IsFinished == true)
                    //Где и как присваивается m_FireTimer ?
                    //В методе InitTimers создаю объект m_FireTimer: m_FireTimer = new Timer(m_ShootDelay);
                    //m_FireTimer создаётся один раз при запуске скрипта,
                    //Внутри конструктора вызывается Start(m_ShootDelay).
                    //каждый кадр мы уменьшаем значение внутреннего счётчика таймера (m_CurrentTime) на Time.deltaTime.
                    //А когда он истекает(становится <= 0), IsFinished становится true, и можно стрелять.
                {
                    m_SpaceShip.Fire(TurretMode.Primary);

                    m_FireTimer.Start(m_ShootDelay);
                    //После выстрела таймер перезапускается.
                    //Таким образом: Таймер "тикает" в UpdateTimers() — у него уменьшается время каждый кадр.
                    //В ActionFire() таймер проверяется и при завершении снова запускается на m_ShootDelay.
                }
            }
        }

        private Destructible FindNearestDestructibleTarget()
        {
            float maxDist = float.MaxValue;

            Destructible potentialTarget = null;

            foreach (var v in Destructible.AllDestructbles)
            {
                if (v.GetComponent<SpaceShip>() == m_SpaceShip) continue;

                if (v.TeamId == Destructible.TeamIdNeutral) continue;

                if (v.TeamId == m_SpaceShip.TeamId) continue;

                float dist = Vector2.Distance(m_SpaceShip.transform.position, v.transform.position);

                if (dist < maxDist)
                {
                    maxDist = dist;
                    potentialTarget = v;
                    //Этот код не выбирает навсегда минимальное расстояние, он каждый кадр или
                    //каждый вызов перебирает всех врагов, сравнивая их дистанции с maxDist.
                    //Что это значит?
                    //maxDist изначально устанавливается в очень большое число(например, float.MaxValue) перед началом перебора целей.
                    //Затем идёт цикл по всем возможным целям(врагам, кораблям и т.д.).
                    //Для каждой цели считается расстояние, и если оно меньше, чем maxDist, то:
                    // -- maxDist обновляется.
                    // -- текущая цель запоминается как наиболее близкая(m_SelectedTarget = v).
                    //Поэтому:
                    //Это условие срабатывает только в пределах одного поиска.
                    //А значит, бот всегда выбирает ближайшую цель на данный момент, а не только ту, которая когда - то была ближе всех.
                    //Бот каждый раз (каждый кадр) ищет ближайшую цель заново, с maxDist сброшенным до очень большого значения.
                    //Бот всегда стреляет в ближайшую из доступных целей на текущий момент.
                }
            }
            return potentialTarget;
        }


        #region Timers

        private void InitTimers()  // Инициализирую все наши таймеры
        {
            //Зачем вообще создавать эти таймеры?
            //Без этих таймеров бот, например:
            //Мгновенно выбирал бы новую цель на каждом кадре, что неэффективно и может быть нестабильно.
            //Стрелял бы без пауз — на каждом кадре, что выглядело бы как чит.
            //Постоянно менял бы направление — непредсказуемо и некрасиво.
            //А с таймерами мы делаем поведение более живым, логичным и управляемым.
            //Что делает InitTimers()?Создаёт три новых таймера:
            //m_RandomizeDirectionTimer — отвечает за рандомизацию направления движения бота.
            //m_FireTimer — управляет частотой выстрелов(не даёт стрелять слишком часто).
            //m_FindNewTargetTimer — регулирует, как часто бот выбирает новую цель.
            //зачем создаются три экземпляра класса?
            //Потому что каждая задача требует отдельного отсчёта времени.

            m_RandomizeDirectionTimer = new Timer(m_RandomSelectMovePointTime);
            //m_RandomizeDirectionTimer — это переменная типа Timer
            //Она хранит информацию о времени до следующего события.
            //new Timer(m_RandomSelectMovePointTime) — создаётся новый объект таймера
            //m_RandomSelectMovePointTime — это число от 0.0 до 1.0 (настраивается в инспекторе),
            //которое означает интервал времени в секундах между выбором новой точки движения.
            //Например, если там стоит 0.6, то бот будет менять направление каждые 0.6 секунды.
            // Без таймера m_RandomizeDirectionTimer у меня БЫ каждый кадр создавал новую
            // случайную точку, и кораблик не долетаю до этой точки летел бы уже к следующей точке.
            //Без таймера корабль БЫ постоянно менял цель. 

            m_FireTimer = new Timer(m_ShootDelay);
            m_FindNewTargetTimer = new Timer(m_FindNewTargetTime);
        }

        //Где и как таймер обновляется?
        private void UpdateTimers()
        {
            //Метод UpdateTimers() вызывается каждый кадр — это значит, что он участвует в игровом цикле (в Update() или его аналоге).
            //Внутри UpdateTimers() для каждого из трёх объектов класса Timer вызывается метод RemoveTime(Time.deltaTime).
            //Метод RemoveTime уменьшает значение поля m_CurrentTime, тем самым "тикает" таймер.
            //Как только m_CurrentTime достигает 0 или меньше, таймер считается завершённым — это проверяется через свойство IsFinished == true.
            //Именно на основе этого флага(в других методах, например ActionFire, FindNewTarget, RandomizeDirection) происходит
            //принятие решений: можно ли стрелять, можно ли поменять направление, можно ли искать цель и т.д.
            //Поле m_CurrentTime не является общим для всех таймеров — у каждого из трёх объектов (m_FireTimer,
            //m_FindNewTargetTimer, m_RandomizeDirectionTimer) своё собственное значение m_CurrentTime.
            //Уточнение: "которое доступно для всех трёх объектов-таймеров" — не совсем точно.У каждого объекта Timer своя копия этого поля.
            //Сам UpdateTimers() не запускает действия, он просто "тикает" таймеры.А действия срабатывают в других методах,
            //которые смотрят: а не пора ли стрелять, менять направление или искать новую цель.

            //В методе UpdateTimers() мы каждый кадр уменьшаем значение времени у трёх объектов класса Timer,
            //используя метод RemoveTime(Time.deltaTime). Этот метод уменьшает значение внутреннего поля m_CurrentTime
            //у каждого таймера. Когда оно становится меньше или равно нулю, соответствующее свойство IsFinished становится true.
            //То есть:  if (m_FireTimer.IsFinished == true),
            //          if (m_FindNewTargetTimer.IsFinished == true),
            //          if (m_RandomizeDirectionTimer.IsFinished == true). 
            //Тогда методы (ActionFire, FindNewTarget, RandomizeDirection) получают сигнал: "Таймер истёк — пора
            //выполнить действие!" Таким образом, метод UpdateTimers() отвечает за "ход времени" в логике поведения бота,
            //и без него ни одно из этих действий не запустится вовремя.

            m_RandomizeDirectionTimer.RemoveTime(Time.deltaTime);
            //Каждый вызов RemoveTime(deltaTime) уменьшает текущее время таймера.
            //То есть — таймер "тикает". Секунда за секундой, кадр за кадром.
            //Это очень важная строка. Каждый кадр она уменьшает значение таймера на прошедшее время (обычно 1/60 секунды),
            //чтобы таймер "шёл" во времени. Без этого он бы никогда не закончился.
            //Time.deltaTime — это время, прошедшее с предыдущего кадра (обычно ~0.016 секунды при 60 FPS).
            //Каждый вызов RemoveTime(deltaTime) уменьшает текущее время таймера.
            //То есть — таймер "тикает".Секунда за секундой, кадр за кадром.
            m_FireTimer.RemoveTime(Time.deltaTime);
            m_FindNewTargetTimer.RemoveTime(Time.deltaTime);

        }

        public void SetPatrolBehavoiur(AIPointPatrol point) // если у меня изменилось поведение или спавнер заспавнил моего бота,
                                                            // то мы должны задать эту точку и задать стартовые параметры
        {
            m_AIBehaviour = AIBehaviour.Patrol;
            m_PatrolPoint = point;
        }

        #endregion  //Здесь инициализируем и обновляем таймеры
    }
}

